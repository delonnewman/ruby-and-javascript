---
layout: default
---
<h1>{{ site.title }}</h1>

<h2 id="overview">Overview</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Appearance</th>
      <td>1995</td>
      <td>1995</td>
    </tr>
    <tr>
      <th>Original Author</th>
      <td>Yukihiro Matsumoto (aka "Matz")</td>
      <td>Brendan Eich</td>
    </tr>
    <tr>
      <th>Major Influences</th>
      <td>Scheme, Smalltalk, Perl</td>
      <td>Scheme, Self, Java, Perl</td>
    </tr>
    <tr>
      <th>Paradigms</th>
      <td>Object-Oriented, Functional, Imperative, Meta</td>
      <td>Object-Oriented, Functional, Imperative, Meta</td>
    </tr>
    <tr>
      <th>Type Discipline</th>
      <td>Dynamic, Strong</td>
      <td>Dynamic, Weak</td>
    </tr>
  </tbody>
</table>

<h2 id="implementation">Implementation</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Standardization</th>
      <td>While there is an ISO standard for Ruby, MRI (whose development is lead by Matz) is generally regarded as the reference implementation.</td>
      <td>ECMAScript</td>
    </tr>
    <tr>
      <th>Implementations</th>
      <td>MRI, MRuby, JRuby, DragonRuby, Opal, TruffleRuby, ArtichokeRuby (see <a target="awesome-rubies" href="https://github.com/planetruby/awesome-rubies">Awesome Rubies</a>
      for more).</td>
      <td>V8, SpiderMonkey, JavaScriptCore, Rhino, Chakra, many more in whole or in part.</td>
    </tr>
    <tr>
      <th>Versions</th>
      <td>Generally versions of Ruby are referred to by their MRI version</td>
      <td>Because there is no reference implementation, versions generally follow the standards
      ECMAScript 5th edition (ES5), ECMAScript 6th edition (ECMAScript 2015, ES6) will be covered here.</td>
    </tr>
  </tbody>
</table>

<h2 id="syntax">Syntax</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Type Hierarchy</th>
      <td>Like Smalltalk, every value is decendent from a single type <code>Object</code> (or <code>BasicObject</code> after Ruby 1.9).</td>
      <td>Similar to Java, JavaScript has 5 primitive types: <code>number</code>, <code>boolean</code>, <code>string</code>, <code>null</code>,
      <code>undefined</code>, and one extension type: <code>Object</code>. ES6 adds <code>symbol</code> and <code>bigint</code>. All other
      types decend from <code>Object</code>.</td>
    </tr>
    <tr>
      <th scope="row">Let's talk about nothing</th>
      <td><code>nil</code> is a singleton instance of <code>NilClass</code>.</td>
      <td>As in some Scheme implementations, <code>null</code> and <code>undefined</code>
      are two primitive types that in different contexts represent nothing.
      When a function has no return value it returns <code>undefined</code>,
      when an object lacks a key it returns <code>undefined</code>. <code>null</code> is
      used in much the same way as <code>nil</code> in Ruby.</td>
    </tr>
    <tr>
      <th>Booleans</th>
      <td><code>true</code> is a singleton instance of <code>TrueClass</code>
      and <code>false</code> is a singleton instance of <code>FalseClass</code>.</td>
      <td><code>true</code> and <code>false</code> are the two instances of the primitive
      type <code>boolean</code></td>
    </tr>
    <tr>
      <th scope="row">Falsy</th>
      <td><code>false</code> and <code>nil</code> are considered "false" in boolean contexts (e.g. conditional statements), anything else is considered "true".</td>
      <td><code>false</code>, <code>null</code>, <code>undefined</code>, <code>0</code>, <code>''</code>, and <code>NaN</code>,
      are all considered "false" in boolean contexts, anything else is considered "true".</td>
    </tr>
    <tr>
      <th scope="row">Numbers</th>
      <td>All numeric types are subclasses of <code>Numeric</code>. These types include:
      <code>Integer</code>, <code>Float</code>, and <code>Rational</code>.</td>
      <td>In ES5 numbers are of the primitive type <code>number</code>. ES6 adds a <code>bigint</code> type.
      Numbers are any IEEE floating point number and <code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code> which are the result of
      certain mathematical operations like <code>1 / 0</code>.</td>
    </tr>
    <tr>
      <th scope="row">Strings</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Regular Expressions</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Symbols</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Array Literals</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Hash Literals</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Object Literals</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Operators</th>
      <td>Operators (e.g. <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>) are syntactic sugar for methods. As such, their behavior
      can be defined and redefined on a per-class basis (see <a href="#object-oriented-programming">Object-Oriented Programming</a>,
      <a href="#operator-comparision">Operator Comparison</a>).</td>
      <td>Operators are predefined and cannot be changed or defined for new objects (see <a href="#operator-comparision">Operator Comparison</a>).</td>
    </tr>
  </tbody>
</table>

<h2 id="control-flow">Control Flow</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Statements vs. Expressions</th>
      <td>Like Scheme, Ruby is expression oriented, i.e. everything returns a value including language primitives like <code>if</code> and
      <code>for</code>.</td>
      <td>Like Java and C, JavaScript makes a distinction between language statements like <code>if</code> and <code>for</code> and
        expressions like <code>2 + 3</code> or <code>3 + 4 == 7</code>.</td>
    </tr>
    <tr>
      <th scope="row">Functions / Methods</th>
      <td>
        <pre><code>
        def add1(x)
          x + 1
        end
        </code></pre>
        <p>Since most everything in Ruby is an object or a method (see <a href="object-oriented-programming">Object Oriented Programming</a>). What are sometimes called "functions" are
        really methods (i.e. "functions" that belong to a class). If you define a method outside of a class or module (for example in a short script) it gets added to <code>Object</code>.</p>
        <p>Like everything else in Ruby, method definitions are expressions, they evaluate to their name as a symbol so the method above will evaluate to <code>:add1</code>.</p>
        <p>Ruby also has at least one other type that can be used to model functions (see <a href="object-oriented-programming">Functional Programming</a>).</p>
        <p>When called a method returns the value of the last expression that has been evaluated, so <code>return</code> is only required if you want to terminate execution early.
        Which means that this:</p>
        <pre><code>
        def add1(x)
          return x + 1
        end
        </code></pre>
        <p>is the same as the first example, but this:</p>
        <pre><code>
        def add1(x)
          return nil if x.nil?

          x + 1
        end
        </code></pre>
        <p>is not.</p>
      </td>
      <td>
        <pre><code>
        function add1(x) {
            return x + 1;
        }
        </code></pre>
        <p>Generally functions are statements (i.e. they don't evaluate to any value), but under certain circumstances they are evaluated as expressions. The rules are complex
        so we'll just cover two cases that are generally useful to know.</p>
        <p>Functions are expressions when they are part of an assignment expression.</p>
        <pre><code>
        var add1 = function(x) {
            return x + 1;
        };
        </code></pre>
        <p>Note the semicolon at the end of the expression is required.</p>
        <p>Functions are also expressions when they are a part of an object expression.</p>
        <pre><code>
        var Numeric = {
            add1: function(x) { return x + 1; },
            sub1: function(x) { return 1 - x; }
        };
        </code></pre>
        <p>When evaluated, as an expression a <code>Function</code> object is returned (see <a href="#object-oriented-programming">Object Oriented Programming</a>,
        <a href="#functional-programming">Functional Programming</a>).</p>
        <p>When called, the function will return the value given by the first <code>return</code> statement that is executed or <code>undefined</code> if nothing is returned.</p>
      </td>
    </tr>
    <tr>
      <th scope="row">Conditionals</th>
      <td class="overflow-auto">
        <!-- Ruby Conditionals -->
        <pre><code>
        if x &lt; 0
          puts 'Negative'
        elsif x &gt; 0
          puts 'Positive'
        else
          puts 'Zero'
        end
        </code></pre>
        <p>Like Perl, Ruby also supports conditionals appended after a statement, e.g.:</p>
        <pre><code>puts 'Negative' if x &lt; 0</code></pre>
        <p>In this case, "Negative" will be printed to the screen if <code>x</code> is less than zero.</p>
        <p>Also like Perl, Ruby supports a negated conditional statement <code>unless</code>.</p>
        <pre><code>
        unless x &lt; 0
          puts 'Positive'
        end
        </code></pre>
        <p>or</p>
        <pre><code>
        puts 'Positive' unless x &lt; 0
        </code></pre>
        <p>Conditional expressions evaluate to the last expression that has been evaluated. So</p>
        <pre><code>
        polarity = if x &lt; 0
                     'Negative'
                   elsif x &gt; 0
                     'Positive'
                   else
                     'Zero'
                   end
        
        puts polarity</code></pre>
        <p>will yield the same results as the first example.</p>
        <p>Ruby also supports an optional <code>then</code> keyword:</p>
        <pre><code>
        if x &lt; 0 then
          'Negative'
        elsif x &gt; 0
          'Positive'
        else
          'Zero'
        end
        </code></pre>
        <p>This can be useful for inline conditionals:</p>
        <pre><code>
        polarity = if x &lt; 0 then 'Negative' else 'Positive' end
        puts polarity
        </code></pre>
      </td>
      <td>
        <!-- JavaScript Conditionals -->
        <pre><code>
        if (x &lt; 0) {
            console.log('Negative');
        }
        else if (x &gt; 0) {
            console.log('Positive');
        }
        else {
            console.log('Zero');
        }
        </code></pre>
        <p>Like C and Java curly braces are only required when the clause is associated with more than one statement. This is a
        feature that requires some caution, because:</p>
        <pre><code>
        if (x &lt; 0)
            console.log('Negative');
            console.log('Less than zero');
        </code></pre>
        is not the same thing as
        <pre><code>
        if (x &lt; 0) {
            console.log('Negative');
            console.log('Less than zero');
        }
        </code></pre>
      </td>
    </tr>
    <tr>
      <th scope="row">Case / Switch</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Imperative Block</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">For</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">While</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Do / While</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Exception Handling</th>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>

<h2 id="variable-scope">Variable Scope</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Local</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Global</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Function</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Instance</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Class</th>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>

<h2 id="operator-comparison">Operator Comparison</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Boolean</th>
      <td><code>||</code>, <code>&amp;&amp;</code>, <code>!</code>, <code>or</code>, <code>and</code>, <code>not</code></td>
      <td><code>||</code>, <code>&amp;&amp;</code>, <code>!</code></td>
    </tr>
    <tr>
      <th scope="row">Bitwise</th>
      <td><code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
      <td><code>|</code>, <code>&amp;</code>, <code>^</code>, <code>~</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></td>
    </tr>
    <tr>
      <th scope="row">Arithmetic</th>
      <td><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>, <code>**</code></td>
      <td><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code></td>
    </tr>
    <tr>
      <th scope="row">Comparison</th>
      <td><code>==</code>, <code>===</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=&gt;</code></td>
      <td><code>==</code>, <code>===</code>, <code>&lt;</code>, <code>&gt;</code></td>
    </tr>
    <tr>
      <th scope="row">General-Purpose Matching</th>
      <td><code>===</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <th scope="row">Regular Expression Matching</th>
      <td><code>=~</code>, <code>!~</code>, <code>===</code></td>
      <td><code>=~</code>, <code>!~</code></td>
    </tr>
    <tr>
      <th scope="row">String Concatenation</th>
      <td><code>+</code></td>
      <td><code>+</code></td>
    </tr>
    <tr>
      <th scope="row">Ternary</th>
      <td><code>?:</code></td>
      <td><code>?:</code></td>
    </tr>
    <tr>
      <th scope="row">Assignment</th>
      <td><p><code>=</code>, supports multiple assignment with array or multiple values, e.g. <code>x, y = [1, 2]</code> or <code>a, b = 3, 4</code>.</p>
      <p>The following compound assignment operators are supported which perform the binary operation indicated before the <code>=</code> on the value and the variable and
      reassigns that value to the variable: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>||=</code>, <code>&amp;&amp;=</code>,
      <code>|=</code>, <code>&amp;=</code>, <code>^=</code>, <code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>.</p>
      <p>For example, <code>x += 1</code> increments the value of <code>x</code>.</p></td>
      <td><p><code>=</code>, ES6 supports multiple assignment and destructuring on arrays and objects, e.g. <code>[x, y] = [1, 2]</code> or <code>{a, b} = {a: 1, b: 2}</code></p>
      <p>The following compound assignment operators are supported which perform the binary operation indicated before the <code>=</code> on the value and the variable and
      reassigns that value to the variable: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>||=</code>, <code>&amp;&amp;=</code>,
      <code>|=</code>, <code>&amp;=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>.</p></td>
    </tr>
    <tr>
      <th scope="row">Increment / Decrement</th>
      <td>N/A</td>
      <td><code>++</code>, <code>--</code></td>
    </tr>
    <tr>
      <th scope="row">Object Instantiation</th>
      <td>N/A, objects are instantiated from constructor methods. Ruby provides a default constructor <code>new</code> that can be used
      by not defining a constructor or defining a method called <code>initialize</code> that will be called by the default constructor.</td>
      <td><code>new</code></td>
    </tr>
    <tr>
      <th scope="row">Object Method Invocation</th>
      <td><code>.</code>, <code>&amp;.</code></td>
      <td>N/A, method invocation results from calling a function that is a member of an object (see Object Member Access below).</td>
    </tr>
    <tr>
      <th scope="row">Object Member Access</th>
      <td>N/A, object members are always private, with out resorting to meta-programming, member access can only be acheived by defining an attribute method for the
      class (see Object Method Invocation above).</td>
      <td><code>.</code>, <code>[]</code></td>
    </tr>
    <tr>
      <th scope="row">Collection Element Reference</th>
      <td><code>[]</code></td>
      <td><code>[]</code></td>
    </tr>
    <tr>
      <th scope="row">Namespacing</th>
      <td><code>::</code></td>
      <td>N/A</td>
    </tr>
    <tr>
      <th scope="row">Reflection</th>
      <td><code>defined?</code>, <code>===</code></td>
      <td><code>instanceof</code>, <code>typeof</code></td>
    </tr>
    <tr>
      <th scope="row">Range</th>
      <td><code>..</code>, <code>...</code></td>
      <td>N/A</td>
    </tr>
  </tbody>
</table>

<h2 id="collections">Collections</h2>

<table class="table">
  <thead class="thead-light">
    <tr>
      <th scope="col"></th>
      <th scope="col">Ruby</th>
      <th scope="col">JavaScript</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th scope="row">Array</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Hash / Map</th>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th scope="row">Set</th>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>

<h2 id="object-oriented-programming">Object Oriented Programming</h2>

<h2 id="functional-programming">Functional Programming</h2>

<h2 id="meta-programming">Meta Programming</h2>

<h2 id="references">References</h2>

- https://brendaneich.com/2008/04/popularity/
